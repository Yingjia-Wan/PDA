You are a math expert familiar with the Lean 4 theorem prover, a tool used for formal verification of mathematical theorems and proofs. 
Given a statement and its proof written in Lean 4‚Äôs syntax, please translate the statement and its corresponding proof into the semantically equivalent natural language that can be understood by a human reader. The translation should accurately convey the same logical structure and content as the original statement and proof. 
You need to explain the theorem and proof in the most intuitive terms as possible, but also maintain the fidelity of the original mathematical reasoning.
To do so, describe the details for each step of the proof based on the meaning of the lemma to ensure translation fidelity and precision, and then summarize the proof in simpler and intuitive terms to ensure human-readability.
---
Follow the following format.
# Theorem: (theorem and proof in lean 4, to be translated)
# Problem: (translated theorem)
# Proof: (translated proof)
---
Here are some examples:

# Theorem: theorem inv_ne_zero : a‚àí1 ‚â† 0 ‚Üî a ‚â† ‚àû := by simp\n #align ennreal.inv_ne_zero ENNReal.inv_ne_zero\n\n
# Problem: For any number a in the extended non-negative real numbers, the inverse of a is not zero if and only if a is not infinity.
# Proof: The step-by-step proof for the problem is as follows:
1. Assume a ‚â† ‚àû: This means that a is either a finite real number or negative infinity.
2. If a is a finite real number: The inverse of a non-zero finite real number is always a non-zero finite real number. Therefore, a^-1 ‚â† 0.
3. If a = -‚àû: The inverse of negative infinity is 0. However, we assumed a ‚â† ‚àû, so this case is not possible.
4. Therefore, in all cases, a^-1 ‚â† 0 if a ‚â† ‚àû.
In simpler terms, the proof of this theorem essentially says that if a is not infinity, then it must be a finite real number. And since the inverse of a non-zero finite real number is also a non-zero finite real number, a^-1 cannot be zero.

# Theorem: theorem comap_pure {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) := by\n   rw [‚Üê principal_singleton, comap_principal]\n 
# Problem:  If you have a value `b` and you want to find all the possible ways to get that value using a monad `m`, you can do it in two ways: \n\n1. **Directly:** You can use the `comap` function to lift the pure value `b` into the monad `m` and then find all the possible ways to get that lifted value. \n\n2. **Indirectly:** You can find all the elements in the monad `m` that map to `b` using the inverse image of the singleton set `{b}` under the function `m`. Then, you can take the powerset of this set to get all the possible combinations of these elements. \n\nThe theorem states that both methods give you the same result.
# Proof: The proof uses two lemmas to rewrite the equation and show that both sides are equivalent:\n\n
1. **`rw [‚Üê principal_singleton, comap_principal]`**: This step rewrites the equation using the following two lemmas:\n    * **`principal_singleton`**: This lemma says that if you have a set containing only one element `b`, then the set of all sets that contain `b` is the same as the set of all sets that are part of the principal filter of `{b}`. This is used to rewrite the right-hand side of the equation.\n    * **`comap_principal`**: This lemma says that if you have a principal filter and you apply the `comap` function to it, you get the preimage of the filter under the function `m`. This is used to rewrite the left-hand side of the equation.\n\n
2. **`by`**: This keyword indicates that the proof is complete after the rewriting step. The rewriting step itself is sufficient to prove the equality.
In simpler terms, this theorem shows that you can find all the possible ways to get a value `b` in a monad by either directly lifting the value into the monad or by finding all the elements in the monad that map to `b` and taking their powerset. Both methods are equivalent and give you the same result.

# Theorem: theorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 := by ext\n
# Problem: Any function `f` from a type `X` to the empty type `0` must be the zero function. In other words, there's no way to create a function that actually maps elements from `X` to the empty type.
# Proof: The proof uses the `ext` tactic, which stands for 'extensionality'. This tactic allows us to prove that two functions are equal by showing that they produce the same output for every possible input.\n\n1. **`ext`**: This tactic tells Lean to automatically generate a proof that the functions are equal by considering all possible inputs. Since the target type is the empty type `0`, there are no possible inputs to consider. \n\n2. **`by`**: This keyword indicates that the proof is complete after the `ext` tactic is applied. Since there are no inputs to consider, the proof is trivially true.
In simpler terms, the theorem is true because the empty type `0` has no elements. Therefore, there's no way to map elements from `X` to `0` because there's nowhere to map them to. The proof uses the `ext` tactic to automatically handle this case, showing that the theorem holds because there are no possible inputs to consider.

# Theorem: {Theorem}
# Problem: 
